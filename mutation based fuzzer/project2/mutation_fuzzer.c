#include <stdio.h>
#include <stdlib.h>
#include <string.h>
#include <unistd.h>
#include <sys/wait.h>

int main(void){ 
	FILE *input_file, *output_file;
    
    char input_buff[2000];    
    char output_buffer[20];	
	
	int system_response,response_code;
	static char exe_response_buff[100];
   
	char crashed_img[40];
	char exec_command[200];
	
	int time = 0,crash_counter=0;
	
	int read_bytes;
	int bug_no;
	int BUG1=0,BUG2=0,BUG3=0,BUG4=0,BUG5=0,BUG6=0,BUG7=0,BUG8=0;
	// change total_iterations to increase  bug count occurrence.
    int total_iterations = 2000; 
	int index;
	
	for(index=1;index<=total_iterations;index++)
    {
    
	input_file=fopen("./cross.jpg","rb");
    output_file=fopen("./test.jpg", "wb");
	
    
	
	fseek(input_file,0,SEEK_END);
    read_bytes=ftell(input_file);
    fseek(input_file,0,SEEK_SET);
	
	
    fread (input_buff,1,read_bytes,input_file);
	
	// can remove this if stmt and keep only else part but we need more iterations(10k) to produce BUG-1
	
	if(index%48==0){
		
		
		input_buff[index] = rand()%10+1;
		
		
		
	}else{
		
		int index_buff = (rand() % 800);
		input_buff[index_buff]=rand()%800;
	}
	
	fwrite(input_buff,1,read_bytes,output_file);
	
    fclose(input_file);
	fclose(output_file);
	
	
	sprintf(exec_command,"./jpg2bmp test.jpg test.bmp");
	system_response = system(exec_command);
 
    wait(&time);
	
    response_code = WEXITSTATUS(system_response); 
    
	if(response_code==128+11 || response_code ==128+6)
	
	{
        // Setup the pipe for reading and execute the command. 2>&1 redirects stderr to stdout
     	FILE *process_output = popen("./jpg2bmp test.jpg test.bmp 2>&1", "r");
		// Grab data into exe_response_buff from process execution
        while (fgets(exe_response_buff, sizeof(exe_response_buff), process_output) != NULL)
      	break;
        pclose(process_output);

        if(exe_response_buff[0]=='B' && exe_response_buff[1]=='u' && exe_response_buff[2]=='g') {
				bug_no = atoi(&exe_response_buff[5]);
        switch(bug_no)
        {
          case 1: BUG1++;
          break;
          case 2: BUG2++;
          break;
          case 3: BUG3++;
          break;
          case 4: BUG4++;
          break;
          case 5: BUG5++;
          break;
          case 6: BUG6++;
          break;
          case 7: BUG7++;
          break;
          case 8: BUG8++;
          break;
          default: break;
        }
				sprintf(output_buffer,"./test-%d.jpg", bug_no);
				output_file=fopen(output_buffer, "wb");
				fwrite(input_buff,1,read_bytes,output_file);
				fclose(output_file);

        }
    		
			 
			    
		// comment the following 6 lines to avoid creating crashed images.
		crash_counter = crash_counter + 1;
        sprintf(crashed_img,"./crashed-%d.jpg",crash_counter);
		fprintf(stderr,"crashed image : %s\n",crashed_img);
		
       output_file=fopen(crashed_img, "wb");
       fwrite (input_buff,1,read_bytes,output_file);
        fclose(output_file);
       
    
	}
	
	
	
	
}
  printf("\nTotal segmentation faults:%d\n",crash_counter);
  printf(" Total number of times Bug 1 occurred: %d\n", BUG1 );
  printf(" Total number of times Bug 2 occurred: %d\n", BUG2 );
  printf(" Total number of times Bug 3 occurred: %d\n", BUG3 );
  printf(" Total number of times Bug 4 occurred: %d\n", BUG4 );
  printf(" Total number of times Bug 5 occurred: %d\n", BUG5 );
  printf(" Total number of times Bug 6 occurred: %d\n", BUG6 );
  printf(" Total number of times Bug 7 occurred: %d\n", BUG7 );
  printf(" Total number of times Bug 8 occurred: %d\n", BUG8 );
  
  return 0;
}
